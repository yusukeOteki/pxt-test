/// <reference path="../localtypings/pxtblockly.d.ts" />
/// <reference path="pxtlib.d.ts" />
/// <reference path="../localtypings/blockly.d.ts" />
/// <reference path="pxtsim.d.ts" />
declare let iface: pxt.worker.Iface;
declare namespace pxt.blocks {
    function workerOpAsync(op: string, arg: pxtc.service.OpArg): Promise<any>;
    class Point {
        link: Point;
        type: string;
        parentType: Point;
        childType: Point;
        constructor(link: Point, type: string, parentType?: Point, childType?: Point);
    }
    function compileExpression(e: Environment, b: Blockly.Block, comments: string[]): JsNode;
    interface Environment {
        workspace: Blockly.Workspace;
        bindings: Binding[];
        stdCallTable: pxt.Map<StdFunc>;
        errors: Blockly.Block[];
        renames: RenameMap;
        stats: pxt.Map<number>;
        enums: pxtc.EnumInfo[];
    }
    interface RenameMap {
        oldToNew: Map<string>;
        takenNames: Map<boolean>;
        oldToNewFunctions: Map<string>;
    }
    enum VarUsage {
        Unknown = 0,
        Read = 1,
        Assign = 2,
    }
    interface Binding {
        name: string;
        type: Point;
        declaredInLocalScope: number;
        assigned?: VarUsage;
        mustBeGlobal?: boolean;
    }
    function escapeVarName(name: string, e: Environment, isFunction?: boolean): string;
    interface StdFunc {
        f: string;
        comp: BlockCompileInfo;
        attrs: ts.pxtc.CommentAttrs;
        isExtensionMethod?: boolean;
        isExpression?: boolean;
        imageLiteral?: number;
        hasHandler?: boolean;
        property?: boolean;
        namespace?: string;
        isIdentity?: boolean;
    }
    function mkEnv(w: Blockly.Workspace, blockInfo?: pxtc.BlocksInfo, skipVariables?: boolean): Environment;
    function compileBlockAsync(b: Blockly.Block, blockInfo: pxtc.BlocksInfo): Promise<BlockCompilationResult>;
    function callKey(e: Environment, b: Blockly.Block): string;
    interface BlockCompilationResult {
        source: string;
        sourceMap: SourceInterval[];
        stats: pxt.Map<number>;
    }
    function findBlockId(sourceMap: SourceInterval[], loc: {
        start: number;
        length: number;
    }): string;
    function compileAsync(b: Blockly.Workspace, blockInfo: pxtc.BlocksInfo): Promise<BlockCompilationResult>;
}
declare namespace pxt.blocks {
    function initFieldEditors(): void;
    function registerFieldEditor(selector: string, field: Blockly.FieldCustomConstructor, validator?: any): void;
    function createFieldEditor(selector: string, text: string, params: any): Blockly.FieldCustom;
}
declare namespace pxt.blocks {
    function saveWorkspaceXml(ws: Blockly.Workspace): string;
    function getDirectChildren(parent: Element, tag: string): Element[];
    function getBlocksWithType(parent: Document | Element, type: string): Element[];
    function getChildrenWithAttr(parent: Document | Element, tag: string, attr: string, value: string): Element[];
    function getFirstChildWithAttr(parent: Document | Element, tag: string, attr: string, value: string): Element;
    /**
     * Loads the xml into a off-screen workspace (not suitable for size computations)
     */
    function loadWorkspaceXml(xml: string, skipReport?: boolean): Blockly.Workspace;
    /**
     * This callback is populated from the editor extension result.
     * Allows a target to provide version specific blockly updates
     */
    let extensionBlocklyPatch: (pkgTargetVersion: string, dom: Element) => void;
    function importXml(pkgTargetVersion: string, xml: string, info: pxtc.BlocksInfo, skipReport?: boolean): string;
}
declare namespace pxt.blocks.layout {
    interface FlowOptions {
        ratio?: number;
        useViewWidth?: boolean;
    }
    function patchBlocksFromOldWorkspace(blockInfo: ts.pxtc.BlocksInfo, oldWs: Blockly.Workspace, newXml: string): string;
    /**
     * Splits a blockly SVG AFTER a vertical layout. This function relies on the ordering
     * of blocks / comments to get as getTopBlock(true)/getTopComment(true)
     */
    function splitSvg(svg: SVGSVGElement, ws: Blockly.Workspace, emPixels?: number): Element;
    function verticalAlign(ws: Blockly.Workspace, emPixels: number): void;
    function flow(ws: Blockly.Workspace, opts?: FlowOptions): void;
    function screenshotEnabled(): boolean;
    function screenshotAsync(ws: Blockly.Workspace): Promise<string>;
    function toPngAsync(ws: Blockly.Workspace): Promise<string>;
    function svgToPngAsync(svg: SVGElement, x: number, y: number, width: number, height: number, pixelDensity: number): Promise<string>;
    function toSvgAsync(ws: Blockly.Workspace): Promise<{
        width: number;
        height: number;
        xml: string;
    }>;
    function serializeNode(sg: Node): string;
    function serializeSvgString(xmlString: string): string;
    interface BlockSvg {
        width: number;
        height: number;
        svg: string;
        xml: string;
        css: string;
    }
    function blocklyToSvgAsync(sg: SVGElement, x: number, y: number, width: number, height: number): Promise<BlockSvg>;
    function documentToSvg(xsg: Node): string;
}
declare namespace pxt.blocks {
    const optionalDummyInputPrefix = "0_optional_dummy";
    const optionalInputWithFieldPrefix = "0_optional_field";
    function isArrayType(type: string): boolean;
    function builtinBlocks(): Map<{
        block: Blockly.BlockDefinition;
        symbol?: pxtc.SymbolInfo;
    }>;
    const buildinBlockStatements: Map<boolean>;
    function blockSymbol(type: string): pxtc.SymbolInfo;
    function createFlyoutHeadingLabel(name: string, color?: string, icon?: string, iconClass?: string): HTMLElement;
    function createFlyoutGroupLabel(name: string, icon?: string, labelLineWidth?: string, helpCallback?: string): HTMLElement;
    function createFlyoutButton(callbackkey: string, label: string): Element;
    function createToolboxBlock(info: pxtc.BlocksInfo, fn: pxtc.SymbolInfo, comp: pxt.blocks.BlockCompileInfo): HTMLElement;
    function injectBlocks(blockInfo: pxtc.BlocksInfo): pxtc.SymbolInfo[];
    function hasArrowFunction(fn: pxtc.SymbolInfo): boolean;
    function cleanBlocks(): void;
    /**
     * Used by pxtrunner to initialize blocks in the docs
     */
    function initializeAndInject(blockInfo: pxtc.BlocksInfo): void;
    /**
     * Used by main app to initialize blockly blocks.
     * Blocks are injected separately by called injectBlocks
     */
    function initialize(blockInfo: pxtc.BlocksInfo): void;
    function installHelpResources(id: string, name: string, tooltip: any, url: string, colour: string, colourSecondary?: string, colourTertiary?: string): void;
    let openHelpUrl: (url: string) => void;
    let onShowContextMenu: (workspace: Blockly.Workspace, items: Blockly.ContextMenu.MenuItem[]) => void;
    /**
     * <block type="pxt_wait_until">
     *     <value name="PREDICATE">
     *          <shadow type="logic_boolean">
     *              <field name="BOOL">TRUE</field>
     *          </shadow>
     *     </value>
     * </block>
     */
    function mkPredicateBlock(type: string): HTMLElement;
    function mkFieldBlock(type: string, fieldName: string, fieldValue: string, isShadow: boolean): HTMLElement;
    function getFixedInstanceDropdownValues(apis: pxtc.ApisInfo, qName: string): pxtc.SymbolInfo[];
    function generateIcons(instanceSymbols: pxtc.SymbolInfo[]): void;
    /**
     * Blockly variable fields can't be set directly; you either have to use the
     * variable ID or set the value of the model and not the field
     */
    function setVarFieldValue(block: Blockly.Block, fieldName: string, newName: string): void;
}
declare namespace pxt.blocks {
    /**
     * This interface defines the optionally defined functions for mutations that Blockly
     * will call if they exist.
     */
    interface MutatingBlock extends Blockly.Block {
        mutation: Mutation;
        mutationToDom(): Element;
        domToMutation(xmlElement: Element): void;
        compose(topBlock: Blockly.Block): void;
        decompose(workspace: Blockly.Workspace): Blockly.Block;
    }
    /**
     * Represents a mutation of a block
     */
    interface Mutation {
        /**
         * Get the unique identifier for this type of mutation
         */
        getMutationType(): string;
        /**
         * Compile the mutation of the block into a node representation
         */
        compileMutation(e: Environment, comments: string[]): JsNode;
        /**
         * Get a mapping of variables that were declared by this mutation and their types.
         */
        getDeclaredVariables(): pxt.Map<string>;
        /**
         * Returns true if a variable with the given name was declared in the mutation's compiled node
         */
        isDeclaredByMutation(varName: string): boolean;
    }
    namespace MutatorTypes {
        const ObjectDestructuringMutator = "objectdestructuring";
        const RestParameterMutator = "restparameter";
        const DefaultInstanceMutator = "defaultinstance";
    }
    function addMutation(b: MutatingBlock, info: pxtc.SymbolInfo, mutationType: string): void;
    function mutateToolboxBlock(block: Node, mutationType: string, mutation: string): void;
}
declare namespace pxt.blocks {
    enum BlockLayout {
        Align = 1,
        Clean = 3,
        Flow = 4,
    }
    interface BlocksRenderOptions {
        emPixels?: number;
        layout?: BlockLayout;
        clean?: boolean;
        aspectRatio?: number;
        packageId?: string;
        package?: string;
        snippetMode?: boolean;
        useViewWidth?: boolean;
        splitSvg?: boolean;
    }
    function render(blocksXml: string, options?: BlocksRenderOptions): Element;
    function blocksMetrics(ws: Blockly.Workspace): {
        width: number;
        height: number;
    };
}
declare namespace pxt.docs.codeCard {
    interface CodeCardRenderOptions {
        hideHeader?: boolean;
        shortName?: boolean;
    }
    function render(card: pxt.CodeCard, options?: CodeCardRenderOptions): HTMLElement;
}
declare namespace pxt.blocks {
    interface ComposableMutation {
        mutationToDom(mutationElement: Element): Element;
        domToMutation(savedElement: Element): void;
    }
    function appendMutation(block: Blockly.Block, mutation: ComposableMutation): void;
    function initVariableArgsBlock(b: Blockly.Block, handlerArgs: pxt.blocks.HandlerArg[]): void;
    function initExpandableBlock(b: Blockly.Block, def: pxtc.ParsedBlockDef, comp: BlockCompileInfo, toggle: boolean, addInputs: () => void): void;
}
declare namespace Blockly {
    interface Block {
        moveInputBefore(nameToMove: string, refName: string): void;
        getInput(inputName: string): Blockly.Input;
    }
}
declare namespace pxt.blocks {
    function initMathOpBlock(): void;
}
declare namespace pxt.blocks {
    function initMathRoundBlock(): void;
}
declare namespace pxtblockly {
    class FieldBreakpoint extends Blockly.FieldNumber implements Blockly.FieldCustom {
        isFieldCustom_: boolean;
        private params;
        private state_;
        private checkElement_;
        private toggleThumb_;
        protected CURSOR: string;
        private type_;
        constructor(state: string, params: Blockly.FieldCustomOptions, opt_validator?: Function);
        init(): void;
        updateWidth(): void;
        /**
         * Return 'TRUE' if the toggle is ON, 'FALSE' otherwise.
         * @return {string} Current state.
         */
        getValue(): string;
        /**
         * Set the checkbox to be checked if newBool is 'TRUE' or true,
         * unchecks otherwise.
         * @param {string|boolean} newBool New state.
         */
        setValue(newBool: string): void;
        switchToggle(newState: boolean): void;
        updateTextNode_(): void;
        render_(): void;
        /**
         * Toggle the state of the toggle.
         * @private
         */
        showEditor_(): void;
        private toVal(newState);
        private fromVal(val);
    }
}
declare namespace pxtblockly {
    class FieldColorWheel extends Blockly.FieldSlider implements Blockly.FieldCustom {
        isFieldCustom_: boolean;
        private params;
        private channel_;
        /**
         * Class for a color wheel field.
         * @param {number|string} value The initial content of the field.
         * @param {Function=} opt_validator An optional function that is called
         *     to validate any constraints on what the user entered.  Takes the new
         *     text as an argument and returns either the accepted text, a replacement
         *     text, or null to abort the change.
         * @extends {Blockly.FieldNumber}
         * @constructor
         */
        constructor(value_: any, params: any, opt_validator?: Function);
        /**
         * Set the gradient CSS properties for the given node and channel
         * @param {Node} node - The DOM node the gradient will be set on.
         * @private
         */
        setBackground_(node: Element): void;
        setReadout_(readout: Element, value: string): void;
        createColourStops_(): string[];
        colorWheel(wheelPos: number, channel?: string): string;
        hsvFast(hue: number, sat: number, val: number): string;
        private hex(red, green, blue);
        private componentToHex(c);
    }
}
declare namespace pxtblockly {
    /**
     * The value modes:
     *     hex - Outputs an HTML color string: "#ffffff" (with quotes)
     *     rgb - Outputs an RGB number in hex: 0xffffff
     *     index - Outputs the index of the color in the list of colors: 0
     */
    type FieldColourValueMode = "hex" | "rgb" | "index";
    interface FieldColourNumberOptions extends Blockly.FieldCustomOptions {
        colours?: string;
        columns?: string;
        className?: string;
        valueMode?: FieldColourValueMode;
    }
    class FieldColorNumber extends Blockly.FieldColour implements Blockly.FieldCustom {
        isFieldCustom_: boolean;
        protected colour_: string;
        private colorPicker_;
        private className_;
        private valueMode_;
        constructor(text: string, params: FieldColourNumberOptions, opt_validator?: Function);
        /**
         * Return the current colour.
         * @param {boolean} opt_asHex optional field if the returned value should be a hex
         * @return {string} Current colour in '#rrggbb' format.
         */
        getValue(opt_asHex?: boolean): string;
        /**
         * Set the colour.
         * @param {string} colour The new colour in '#rrggbb' format.
         */
        setValue(colour: string): void;
        showEditor_(): void;
        getColours_(): string[];
    }
}
declare namespace pxtblockly {
    interface FieldGridPickerToolTipConfig {
        yOffset?: number;
        xOffset?: number;
    }
    interface FieldGridPickerOptions extends Blockly.FieldCustomDropdownOptions {
        columns?: string;
        maxRows?: string;
        width?: string;
        tooltips?: string;
        tooltipsXOffset?: string;
        tooltipsYOffset?: string;
        hasSearchBar?: boolean;
        hideRect?: boolean;
    }
    class FieldGridPicker extends Blockly.FieldDropdown implements Blockly.FieldCustom {
        isFieldCustom_: boolean;
        private width_;
        private columns_;
        private maxRows_;
        protected backgroundColour_: string;
        protected borderColour_: string;
        private tooltipConfig_;
        private tooltip_;
        private firstItem_;
        private hasSearchBar_;
        private hideRect_;
        private observer;
        private selectedItemDom;
        private closeModal_;
        private selectedBar_;
        private selectedImg_;
        private selectedBarText_;
        private selectedBarValue_;
        private static DEFAULT_IMG;
        constructor(text: string, options: FieldGridPickerOptions, validator?: Function);
        /**
         * When disposing the grid picker, make sure the tooltips are disposed too.
         * @public
         */
        dispose(): void;
        private createTooltip_();
        /**
         * Create blocklyGridPickerRows and add them to table container
         * @param options
         * @param tableContainer
         */
        private populateTableContainer(options, tableContainer, scrollContainer);
        /**
         * Populate a single row and add it to table container
         * @param row
         * @param options
         * @param tableContainer
         */
        private populateRow(row, options, tableContainer);
        /**
         * Callback for when a button is clicked inside the drop-down.
         * Should be bound to the FieldIconMenu.
         * @param {Event} e DOM event for the click/touch
         * @private
         */
        protected buttonClick_: (e: any) => void;
        protected buttonClickAndClose_: (e: any) => void;
        /**
         * Whether or not to show a box around the dropdown menu.
         * @return {boolean} True if we should show a box (rect) around the dropdown menu. Otherwise false.
         * @private
         */
        shouldShowRect_(): boolean;
        /**
         * Set the language-neutral value for this dropdown menu.
         * We have to override this from field.js because the grid picker needs to redraw the selected item's image.
         * @param {string} newValue New value to set.
         */
        setValue(newValue: string): void;
        /**
         * Closes the gridpicker.
         */
        private close();
        /**
         * Getter method
         */
        private getFirstItem();
        /**
         * Highlight first item in menu, de-select and de-highlight all others
         */
        private highlightFirstItem(tableContainerDom);
        /**
         * Scroll menu to item that equals current value of gridpicker
         */
        private highlightAndScrollSelected(tableContainerDom, scrollContainerDom);
        /**
         * Create a dropdown menu under the text.
         * @private
         */
        showEditor_(): void;
        private positionMenu_(tableContainer);
        private shouldShowTooltips();
        private getAnchorDimensions_();
        private createWidget_(tableContainer);
        private createSearchBar_(tableContainer, scrollContainer, options);
        private createSelectedBar_();
        private updateSelectedBar_(content, value);
        private setupIntersectionObserver_();
        private disposeIntersectionObserver();
        /**
         * Disposes the tooltip DOM.
         * @private
         */
        private disposeTooltip();
        private onClose_();
        /**
         * Sets the text in this field.  Trigger a rerender of the source block.
         * @param {?string} text New text.
         */
        setText(text: string): void;
        /**
         * Updates the width of the field. This calls getCachedWidth which won't cache
         * the approximated width on IE/Microsoft Edge when `getComputedTextLength` fails. Once
         * it eventually does succeed, the result will be cached.
         **/
        updateWidth(): void;
        /**
         * Update the text node of this field to display the current text.
         * @private
         */
        updateTextNode_(): void;
    }
}
declare namespace pxtblockly {
    interface FieldImageDropdownOptions extends Blockly.FieldCustomDropdownOptions {
        columns?: string;
        maxRows?: string;
        width?: string;
    }
    class FieldImageDropdown extends Blockly.FieldDropdown implements Blockly.FieldCustom {
        isFieldCustom_: boolean;
        protected width_: number;
        protected columns_: number;
        protected maxRows_: number;
        protected backgroundColour_: string;
        protected borderColour_: string;
        protected savedPrimary_: string;
        constructor(text: string, options: FieldImageDropdownOptions, validator?: Function);
        /**
         * Create a dropdown menu under the text.
         * @private
         */
        showEditor_(): void;
        /**
         * Callback for when a button is clicked inside the drop-down.
         * Should be bound to the FieldIconMenu.
         * @param {Event} e DOM event for the click/touch
         * @private
         */
        protected buttonClick_: (e: any) => void;
        /**
         * Callback for when the drop-down is hidden.
         */
        protected onHide_(): void;
        /**
         * Sets the text in this field.  Trigger a rerender of the source block.
         * @param {?string} text New text.
         */
        setText(text: string): void;
        /**
         * Updates the width of the field. This calls getCachedWidth which won't cache
         * the approximated width on IE/Microsoft Edge when `getComputedTextLength` fails. Once
         * it eventually does succeed, the result will be cached.
         **/
        updateWidth(): void;
        /**
         * Update the text node of this field to display the current text.
         * @private
         */
        updateTextNode_(): void;
    }
}
declare namespace pxtblockly {
    interface FieldImagesOptions extends pxtblockly.FieldImageDropdownOptions {
        sort?: boolean;
        addLabel?: string;
    }
    class FieldImages extends pxtblockly.FieldImageDropdown implements Blockly.FieldCustom {
        isFieldCustom_: boolean;
        private shouldSort_;
        protected addLabel_: boolean;
        constructor(text: string, options: FieldImagesOptions, validator?: Function);
        /**
         * Create a dropdown menu under the text.
         * @private
         */
        showEditor_(): void;
        protected createTextNode_(text: string): HTMLSpanElement;
    }
}
declare const rowRegex: RegExp;
declare enum LabelMode {
    None = 0,
    Number = 1,
    Letter = 2,
}
declare namespace pxtblockly {
    class FieldMatrix extends Blockly.Field implements Blockly.FieldCustom {
        private static CELL_WIDTH;
        private static CELL_HORIZONTAL_MARGIN;
        private static CELL_VERTICAL_MARGIN;
        private static CELL_CORNER_RADIUS;
        private static BOTTOM_MARGIN;
        private static Y_AXIS_WIDTH;
        private static X_AXIS_HEIGHT;
        private static TAB;
        isFieldCustom_: boolean;
        private params;
        private onColor;
        private offColor;
        private static DEFAULT_OFF_COLOR;
        private matrixWidth;
        private matrixHeight;
        private yAxisLabel;
        private xAxisLabel;
        private cellState;
        private cells;
        private elt;
        private currentDragState_;
        constructor(text: string, params: any, validator?: Function);
        /**
         * Show the inline free-text editor on top of the text.
         * @private
         */
        showEditor_(): void;
        private initMatrix();
        private getLabel(index, mode);
        private dontHandleMouseEvent_;
        private clearLedDragHandler;
        private createCell(x, y);
        private toggleRect;
        private handleRootMouseMoveListener;
        private getColor(x, y);
        private getOpacity(x, y);
        private updateCell(x, y);
        setValue(newValue: string | number, restoreState?: boolean): void;
        render_(): void;
        getValue(): string;
        private restoreStateFromString();
        private updateValue();
        private getYAxisWidth();
        private getXAxisHeight();
    }
}
declare namespace pxtblockly {
    interface FieldNoteOptions extends Blockly.FieldCustomOptions {
        editorColour?: string;
        minNote?: string;
        maxNote?: string;
    }
    class FieldNote extends Blockly.FieldNumber implements Blockly.FieldCustom {
        isFieldCustom_: boolean;
        private note_;
        private colour_;
        private colourBorder_;
        /**
         * default number of piano keys
         * @type {number}
         * @private
         */
        private nKeys_;
        private minNote_;
        private maxNote_;
        /**
         * Absolute error for note frequency identification (Hz)
         * @type {number}
         */
        eps: number;
        /**
         * array of notes frequency
         * @type {Array.<number>}
         * @private
         */
        private noteFreq_;
        /**
         * array of notes names
         * @type {Array.<string>}
         * @private
         */
        private noteName_;
        constructor(text: string, params: FieldNoteOptions, validator?: Function);
        /**
         * Ensure that only a non negative number may be entered.
         * @param {string} text The user's text.
         * @return {?string} A string representing a valid positive number, or null if invalid.
         */
        classValidator(text: string): string;
        /**
         * Install this field on a block.
         */
        init(): void;
        /**
         * Return the current note frequency.
         * @return {string} Current note in string format.
         */
        getValue(): string;
        /**
         * Set the note.
         * @param {string} note The new note in string format.
         */
        setValue(note: string): void;
        /**
         * Get the text from this field.  Used when the block is collapsed.
         * @return {string} Current text.
         */
        getText(): string;
        /**
         * Set the text in this field and NOT fire a change event.
         * @param {*} newText New text.
         */
        setText(newText: string): void;
        /**
        * get the note name to be displayed in the field
        * @return {string} note name
        * @private
        */
        private getNoteName_();
        /**
         * Set a custom number of keys for this field.
         * @param {number} nkeys Number of keys for this block,
         *     or 26 to use default.
         * @return {!Blockly.FieldNote} Returns itself (for method chaining).
         */
        setNumberOfKeys(size: number): FieldNote;
        onHtmlInputChange_(e: any): void;
        /**
         * Create a piano under the note field.
         */
        showEditor_(e: Event): void;
        /**
         * Callback for when the drop-down is hidden.
         */
        private onHide();
        /**
         * Close the note picker if this input is being deleted.
         */
        dispose(): void;
        private updateColor();
    }
}
declare namespace pxtblockly {
    interface FieldNumberDropdownOptions extends Blockly.FieldCustomDropdownOptions {
        min?: number;
        max?: number;
        precision?: any;
    }
    class FieldNumberDropdown extends Blockly.FieldNumberDropdown implements Blockly.FieldCustom {
        isFieldCustom_: boolean;
        private menuGenerator_;
        constructor(value: number | string, options: FieldNumberDropdownOptions, opt_validator?: Function);
        getOptions(): string[][];
    }
}
declare namespace pxtblockly {
    class FieldProcedure extends Blockly.FieldDropdown {
        constructor(funcname: string, opt_validator?: Function);
        getOptions(): string[][];
        init(): void;
        setSourceBlock(block: Blockly.Block): void;
        getValue(): string;
        setValue(newValue: string): void;
        /**
         * Return a sorted list of variable names for procedure dropdown menus.
         * Include a special option at the end for creating a new function name.
         * @return {!Array.<string>} Array of procedure names.
         * @this {pxtblockly.FieldProcedure}
         */
        dropdownCreate(): string[][];
        onItemSelected(menu: any, menuItem: any): void;
    }
}
declare namespace pxtblockly {
    interface FieldProtractorOptions extends Blockly.FieldCustomOptions {
    }
    class FieldProtractor extends Blockly.FieldSlider implements Blockly.FieldCustom {
        isFieldCustom_: boolean;
        private params;
        private circleSVG;
        private circleBar;
        private reporter;
        /**
         * Class for a color wheel field.
         * @param {number|string} value The initial content of the field.
         * @param {Function=} opt_validator An optional function that is called
         *     to validate any constraints on what the user entered.  Takes the new
         *     text as an argument and returns either the accepted text, a replacement
         *     text, or null to abort the change.
         * @extends {Blockly.FieldNumber}
         * @constructor
         */
        constructor(value_: any, params: FieldProtractorOptions, opt_validator?: Function);
        createLabelDom_(labelText: string): HTMLSpanElement[];
        setReadout_(readout: Element, value: string): void;
        private updateAngle(angle);
    }
}
declare namespace pxtblockly {
    interface FieldSpeedOptions extends Blockly.FieldCustomOptions {
        min?: string;
        max?: string;
        label?: string;
    }
    class FieldSpeed extends Blockly.FieldSlider implements Blockly.FieldCustom {
        isFieldCustom_: boolean;
        private params;
        private speedSVG;
        private circleBar;
        private reporter;
        /**
         * Class for a color wheel field.
         * @param {number|string} value The initial content of the field.
         * @param {Function=} opt_validator An optional function that is called
         *     to validate any constraints on what the user entered.  Takes the new
         *     text as an argument and returns either the accepted text, a replacement
         *     text, or null to abort the change.
         * @extends {Blockly.FieldNumber}
         * @constructor
         */
        constructor(value_: any, params: FieldSpeedOptions, opt_validator?: Function);
        createLabelDom_(labelText: string): HTMLSpanElement[];
        setReadout_(readout: Element, value: string): void;
        private updateSpeed(speed);
        private sign(num);
    }
}
declare namespace pxtblockly {
    interface StyleOptions extends Blockly.FieldCustomOptions {
        bold: boolean;
        italics: boolean;
    }
    class FieldStyledLabel extends Blockly.FieldLabel implements Blockly.FieldCustom {
        isFieldCustom_: boolean;
        constructor(value: string, options?: StyleOptions, opt_validator?: Function);
    }
}
declare namespace pxtblockly {
    interface FieldTextDropdownOptions extends Blockly.FieldCustomOptions {
        values: any;
    }
    class FieldTextDropdown extends Blockly.FieldTextDropdown implements Blockly.FieldCustom {
        isFieldCustom_: boolean;
        constructor(text: string, options: FieldTextDropdownOptions, opt_validator?: Function);
    }
}
declare namespace pxtblockly {
    class FieldTextInput extends Blockly.FieldTextInput implements Blockly.FieldCustom {
        isFieldCustom_: boolean;
        constructor(value: string, options: Blockly.FieldCustomOptions, opt_validator?: Function);
    }
}
declare namespace pxtblockly {
    class FieldToggle extends Blockly.FieldNumber implements Blockly.FieldCustom {
        isFieldCustom_: boolean;
        private params;
        private state_;
        private checkElement_;
        private toggleThumb_;
        protected CURSOR: string;
        private type_;
        constructor(state: string, params: Blockly.FieldCustomOptions, opt_validator?: Function);
        init(): void;
        getDisplayText_(): string;
        getTrueText(): string;
        getFalseText(): string;
        updateWidth(): void;
        getInnerWidth(): number;
        getMaxLength(): number;
        getOutputShape(): number;
        /**
         * Return 'TRUE' if the toggle is ON, 'FALSE' otherwise.
         * @return {string} Current state.
         */
        getValue(): string;
        /**
         * Set the checkbox to be checked if newBool is 'TRUE' or true,
         * unchecks otherwise.
         * @param {string|boolean} newBool New state.
         */
        setValue(newBool: string): void;
        switchToggle(newState: boolean): void;
        updateTextNode_(): void;
        render_(): void;
        /**
         * Toggle the state of the toggle.
         * @private
         */
        showEditor_(): void;
        private toVal(newState);
        private fromVal(val);
    }
}
declare namespace pxtblockly {
    class FieldToggleHighLow extends FieldToggle implements Blockly.FieldCustom {
        isFieldCustom_: boolean;
        constructor(state: string, params: Blockly.FieldCustomOptions, opt_validator?: Function);
        getTrueText(): string;
        getFalseText(): string;
    }
}
declare namespace pxtblockly {
    class FieldToggleOnOff extends FieldToggle implements Blockly.FieldCustom {
        isFieldCustom_: boolean;
        constructor(state: string, params: Blockly.FieldCustomOptions, opt_validator?: Function);
        getTrueText(): string;
        getFalseText(): string;
    }
}
declare namespace pxtblockly {
    class FieldToggleUpDown extends FieldToggle implements Blockly.FieldCustom {
        isFieldCustom_: boolean;
        constructor(state: string, params: Blockly.FieldCustomOptions, opt_validator?: Function);
        getTrueText(): string;
        getFalseText(): string;
    }
    class FieldToggleDownUp extends FieldToggle implements Blockly.FieldCustom {
        isFieldCustom_: boolean;
        constructor(state: string, params: Blockly.FieldCustomOptions, opt_validator?: Function);
        getTrueText(): string;
        getFalseText(): string;
    }
}
declare namespace pxtblockly {
    class FieldToggleYesNo extends FieldToggle implements Blockly.FieldCustom {
        isFieldCustom_: boolean;
        constructor(state: string, params: Blockly.FieldCustomOptions, opt_validator?: Function);
        getTrueText(): string;
        getFalseText(): string;
    }
}
declare namespace pxtblockly {
    class FieldTsExpression extends Blockly.FieldTextInput implements Blockly.FieldCustom {
        isFieldCustom_: boolean;
        /**
         * Same as parent, but adds a different class to text when disabled
         */
        updateEditable(): void;
    }
}
declare namespace pxtblockly {
    interface FieldTurnRatioOptions extends Blockly.FieldCustomOptions {
    }
    class FieldTurnRatio extends Blockly.FieldSlider implements Blockly.FieldCustom {
        isFieldCustom_: boolean;
        private params;
        private path_;
        private reporter_;
        /**
         * Class for a color wheel field.
         * @param {number|string} value The initial content of the field.
         * @param {Function=} opt_validator An optional function that is called
         *     to validate any constraints on what the user entered.  Takes the new
         *     text as an argument and returns either the accepted text, a replacement
         *     text, or null to abort the change.
         * @extends {Blockly.FieldNumber}
         * @constructor
         */
        constructor(value_: any, params: FieldTurnRatioOptions, opt_validator?: Function);
        static HALF: number;
        static HANDLE_RADIUS: number;
        static RADIUS: number;
        createLabelDom_(labelText: string): HTMLSpanElement[];
        updateGraph_(): void;
        setReadout_(readout: Element, value: string): void;
    }
}
declare namespace pxtblockly {
    class FieldUserEnum extends Blockly.FieldDropdown {
        private opts;
        constructor(opts: pxtc.EnumInfo);
        init(): void;
        onItemSelected(menu: goog.ui.Menu, menuItem: goog.ui.MenuItem): void;
        private initVariables();
    }
    function getNextValue(members: [string, number][], opts: pxtc.EnumInfo): number;
}
declare namespace pxtblockly {
    namespace svg {
        function hasClass(el: SVGElement, cls: string): boolean;
        function addClass(el: SVGElement, cls: string): void;
        function removeClass(el: SVGElement, cls: string): void;
    }
    function parseColour(colour: string | number): string;
    namespace AudioContextManager {
        function mute(mute: boolean): void;
        function stop(): void;
        function frequency(): number;
        function tone(frequency: number): void;
    }
}
declare namespace pxtblockly {
    type Coord = [number, number];
    /**
     * 16-color sprite
     */
    class Bitmap {
        width: number;
        height: number;
        x0: number;
        y0: number;
        protected buf: Uint8Array;
        constructor(width: number, height: number, x0?: number, y0?: number);
        set(col: number, row: number, value: number): void;
        get(col: number, row: number): number;
        copy(col?: number, row?: number, width?: number, height?: number): Bitmap;
        apply(change: Bitmap): void;
        protected coordToIndex(col: number, row: number): number;
        protected getCore(index: number): number;
        protected setCore(index: number, value: number): void;
    }
    class Bitmask {
        width: number;
        height: number;
        protected mask: Uint8Array;
        constructor(width: number, height: number);
        set(col: number, row: number): void;
        get(col: number, row: number): number;
    }
    function resizeBitmap(img: Bitmap, width: number, height: number): Bitmap;
}
declare namespace pxtblockly {
    import svg = pxt.svgUtil;
    interface ToggleProps {
        baseColor: string;
        borderColor: string;
        backgroundColor: string;
        switchColor: string;
        unselectedTextColor: string;
        selectedTextColor: string;
        leftText: string;
        leftIcon: string;
        rightText: string;
        rightIcon: string;
    }
    class Toggle {
        protected leftElement: svg.Group;
        protected leftText: svg.Text;
        protected rightElement: svg.Group;
        protected rightText: svg.Text;
        protected switch: svg.Rect;
        protected root: svg.Group;
        protected props: ToggleProps;
        protected isLeft: boolean;
        protected changeHandler: (left: boolean) => void;
        constructor(parent: svg.SVG, props: Partial<ToggleProps>);
        protected buildDom(): void;
        toggle(quiet?: boolean): void;
        onStateChange(handler: (left: boolean) => void): void;
        layout(): void;
        translate(x: number, y: number): void;
        height(): number;
        width(): number;
    }
    class Button {
        cx: number;
        cy: number;
        root: svg.Group;
        clickHandler: () => void;
        constructor(root: svg.Group, cx: number, cy: number);
        getElement(): svg.Group;
        addClass(className: string): void;
        removeClass(className: string): void;
        onClick(clickHandler: () => void): void;
        translate(x: number, y: number): void;
        title(text: string): void;
        setDisabled(disabled: boolean): void;
        setSelected(selected: boolean): void;
        protected layout(): void;
        protected editClass(className: string, add: boolean): void;
    }
    class TextButton extends Button {
        protected textEl: svg.Text;
        constructor(root: svg.Group, cx: number, cy: number, text: string, className: string);
        setText(text: string): void;
    }
    class CursorButton extends Button {
        constructor(root: svg.Group, cx: number, cy: number, width: number);
    }
    function mkIconButton(icon: string, width: number, height?: number): TextButton;
    function mkXIconButton(icon: string, width: number, height?: number): TextButton;
    function mkTextButton(text: string, width: number, height: number): TextButton;
    class CursorMultiButton {
        root: svg.Group;
        selected: number;
        buttons: Button[];
        indexHandler: (index: number) => void;
        constructor(parent: svg.Group, width: number);
        protected handleClick(index: number): void;
        onSelected(cb: (index: number) => void): void;
    }
    interface UndoRedoHost {
        undo(): void;
        redo(): void;
    }
    class UndoRedoGroup {
        root: svg.Group;
        undo: TextButton;
        redo: TextButton;
        host: UndoRedoHost;
        constructor(parent: svg.Group, host: UndoRedoHost, width: number, height: number);
        translate(x: number, y: number): void;
        updateState(undo: boolean, redo: boolean): void;
    }
    function mkText(text: string): svg.Text;
}
declare namespace pxtblockly {
    class CanvasGrid {
        protected palette: string[];
        image: Bitmap;
        protected lightMode: boolean;
        protected cellWidth: number;
        protected cellHeight: number;
        private gesture;
        private context;
        private bounds;
        private fadeAnimation;
        protected backgroundLayer: HTMLCanvasElement;
        protected paintLayer: HTMLCanvasElement;
        protected overlayLayer: HTMLCanvasElement;
        constructor(palette: string[], image: Bitmap, lightMode?: boolean);
        repaint(): void;
        applyEdit(edit: Edit, cursorCol: number, cursorRow: number): void;
        drawCursor(edit: Edit, col: number, row: number): void;
        bitmap(): Bitmap;
        outerWidth(): number;
        outerHeight(): number;
        writeColor(col: number, row: number, color: number): void;
        drawColor(col: number, row: number, color: number): void;
        restore(bitmap: Bitmap, repaint?: boolean): void;
        showOverlay(): void;
        hideOverlay(): void;
        resizeGrid(rowLength: number, numCells: number): void;
        setCellDimensions(width: number, height: number): void;
        setGridDimensions(width: number, height?: number, lockAspectRatio?: boolean): void;
        setCellColor(column: number, row: number, color: string, opacity?: number): void;
        down(handler: (col: number, row: number) => void): void;
        up(handler: (col: number, row: number) => void): void;
        drag(handler: (col: number, row: number) => void): void;
        move(handler: (col: number, row: number) => void): void;
        leave(handler: () => void): void;
        updateBounds(top: number, left: number, width: number, height: number): void;
        render(parent: HTMLDivElement): void;
        protected redraw(): void;
        protected drawBackground(): void;
        protected clientToCell(clientX: number, clientY: number): number[];
        private initDragSurface();
        private layoutCanvas(canvas, top, left, width, height);
    }
}
declare namespace pxtblockly {
    interface GalleryItem {
        qName: string;
        src: string;
        alt: string;
    }
    class Gallery {
        protected info: pxtc.BlocksInfo;
        protected contentDiv: HTMLDivElement;
        protected containerDiv: HTMLDivElement;
        protected itemBorderColor: string;
        protected itemBackgroundColor: string;
        protected visible: boolean;
        protected pending: (res: Bitmap, err?: string) => void;
        constructor(info: pxtc.BlocksInfo);
        getElement(): HTMLDivElement;
        show(cb: (res: Bitmap, err?: string) => void): void;
        hide(): void;
        layout(left: number, top: number, height: number): void;
        protected buildDom(): void;
        protected initStyles(): void;
        protected mkButton(src: string, alt: string, value: string, i: number, width: string): void;
        protected resolve(bitmap: Bitmap): void;
        protected reject(reason: string): void;
        protected handleSelection(value: string): void;
        protected getBitmap(qName: string): Bitmap;
        protected getGalleryItems(qName: string): GalleryItem[];
    }
}
declare namespace pxtblockly {
    import svg = pxt.svgUtil;
    interface SpriteHeaderHost {
        showGallery(): void;
        hideGallery(): void;
    }
    class SpriteHeader {
        protected host: SpriteHeaderHost;
        div: HTMLDivElement;
        root: svg.SVG;
        toggle: Toggle;
        undoButton: Button;
        redoButton: Button;
        constructor(host: SpriteHeaderHost);
        getElement(): HTMLDivElement;
        layout(): void;
    }
}
declare namespace pxtblockly {
    import svg = pxt.svgUtil;
    interface ReporterHost extends UndoRedoHost {
        resize(width: number, height: number): void;
    }
    class ReporterBar {
        protected host: ReporterHost;
        protected height: number;
        root: svg.Group;
        cursorText: svg.Text;
        sizeButton: TextButton;
        undoRedo: UndoRedoGroup;
        protected sizePresets: [number, number][];
        protected sizeIndex: number;
        constructor(parent: svg.Group, host: ReporterHost, height: number);
        updateDimensions(width: number, height: number): void;
        hideCursor(): void;
        updateCursor(col: number, row: number): void;
        updateUndoRedo(undo: boolean, redo: boolean): void;
        layout(top: number, left: number, width: number): void;
        setSizePresets(presets: [number, number][], currentWidth: number, currentHeight: number): void;
        protected nextSize(): void;
    }
}
declare namespace pxtblockly {
    import svg = pxt.svgUtil;
    interface SideBarHost {
        setActiveTool(tool: PaintTool): void;
        setActiveColor(color: number): void;
        setToolWidth(width: number): void;
    }
    class SideBar {
        root: svg.Group;
        host: SideBarHost;
        palette: string[];
        protected colorSwatches: svg.Rect[];
        protected pencilTool: Button;
        protected eraseTool: Button;
        protected rectangleTool: Button;
        protected fillTool: Button;
        protected sizeGroup: svg.Group;
        protected buttonGroup: svg.Group;
        protected paletteGroup: svg.Group;
        protected selectedTool: Button;
        protected selectedSwatch: svg.Rect;
        protected colorPreview: svg.Rect;
        constructor(palette: string[], host: SideBarHost, parent: svg.Group);
        setTool(tool: PaintTool): void;
        setColor(color: number): void;
        setCursorSize(size: number): void;
        setWidth(width: number): void;
        translate(left: number, top: number): void;
        protected initSizes(): void;
        protected initTools(): void;
        protected initPalette(): void;
        protected initButton(title: string, icon: string, tool: PaintTool, xicon?: boolean): TextButton;
        getButtonForTool(tool: PaintTool): Button;
    }
}
declare namespace pxtblockly {
    enum PaintTool {
        Normal = 0,
        Rectangle = 1,
        Outline = 2,
        Circle = 3,
        Fill = 4,
        Line = 5,
        Erase = 6,
    }
    class Cursor {
        color: number;
        width: number;
        height: number;
    }
    abstract class Edit {
        protected canvasWidth: number;
        protected canvasHeight: number;
        color: number;
        protected toolWidth: number;
        protected startCol: number;
        protected startRow: number;
        isStarted: boolean;
        constructor(canvasWidth: number, canvasHeight: number, color: number, toolWidth: number);
        abstract update(col: number, row: number): void;
        protected abstract doEditCore(bitmap: Bitmap): void;
        doEdit(bitmap: Bitmap): void;
        start(cursorCol: number, cursorRow: number): void;
        drawCursor(col: number, row: number, draw: (c: number, r: number) => void): void;
    }
    abstract class SelectionEdit extends Edit {
        protected endCol: number;
        protected endRow: number;
        update(col: number, row: number): void;
        protected topLeft(): Coord;
        protected bottomRight(): Coord;
    }
    /**
     * Regular old drawing tool
     */
    class PaintEdit extends Edit {
        protected mask: Bitmask;
        constructor(canvasWidth: number, canvasHeight: number, color: number, toolWidth: number);
        update(col: number, row: number): void;
        drawCursor(col: number, row: number, draw: (c: number, r: number) => void): void;
        protected doEditCore(bitmap: Bitmap): void;
        protected drawCore(col: number, row: number, setPixel: (col: number, row: number) => void): void;
    }
    /**
     * Tool for drawing filled rectangles
     */
    class RectangleEdit extends SelectionEdit {
        protected doEditCore(bitmap: Bitmap): void;
    }
    /**
     * Tool for drawing empty rectangles
     */
    class OutlineEdit extends SelectionEdit {
        protected doEditCore(bitmap: Bitmap): void;
        protected drawRectangle(bitmap: Bitmap, tl: Coord, br: Coord): void;
    }
    /**
     * Tool for drawing straight lines
     */
    class LineEdit extends SelectionEdit {
        protected doEditCore(bitmap: Bitmap): void;
        drawCursor(col: number, row: number, draw: (c: number, r: number) => void): void;
        protected bresenham(x0: number, y0: number, x1: number, y1: number, bitmap: Bitmap): void;
        protected drawCore(col: number, row: number, draw: (c: number, r: number) => void): void;
    }
    /**
     * Tool for circular outlines
     */
    class CircleEdit extends SelectionEdit {
        protected doEditCore(bitmap: Bitmap): void;
        midpoint(cx: number, cy: number, radius: number, bitmap: Bitmap): void;
    }
    class FillEdit extends Edit {
        protected col: number;
        protected row: number;
        start(col: number, row: number): void;
        update(col: number, row: number): void;
        protected doEditCore(bitmap: Bitmap): void;
    }
}
declare namespace pxtblockly {
    class SpriteEditor implements SideBarHost, SpriteHeaderHost {
        protected lightMode: boolean;
        private group;
        private root;
        private paintSurface;
        private sidebar;
        private header;
        private bottomBar;
        private gallery;
        private state;
        private cachedState;
        private edit;
        private activeTool;
        private toolWidth;
        private color;
        private cursorCol;
        private cursorRow;
        private undoStack;
        private redoStack;
        private columns;
        private rows;
        private colors;
        private shiftDown;
        private mouseDown;
        constructor(bitmap: Bitmap, blocksInfo: pxtc.BlocksInfo, lightMode?: boolean);
        setCell(col: number, row: number, color: number, commit: boolean): void;
        render(el: HTMLDivElement): void;
        layout(): void;
        rePaint(): void;
        setActiveColor(color: number, setPalette?: boolean): void;
        setActiveTool(tool: PaintTool): void;
        setToolWidth(width: number): void;
        undo(): void;
        redo(): void;
        resize(width: number, height: number): void;
        setSizePresets(presets: [number, number][]): void;
        canvasWidth(): number;
        canvasHeight(): number;
        outerWidth(): number;
        outerHeight(): number;
        bitmap(): Bitmap;
        showGallery(): void;
        hideGallery(): void;
        switchIconBack(tool: PaintTool): void;
        private keyDown;
        private keyUp;
        addKeyListeners(): void;
        removeKeyListeners(): void;
        private afterResize(showOverlay);
        private drawCursor(col, row);
        private paintEdit(edit, col, row);
        private commit();
        private pushState(undo);
        private restore(bitmap);
        private updateUndoRedo();
        private paintCell(col, row, color);
        private newEdit(color);
        private debug(msg);
        private createDefs();
    }
}
declare namespace pxtblockly {
    interface FieldSpriteEditorOptions {
        sizes: string;
        initColor: string;
        initWidth: string;
        initHeight: string;
    }
    class FieldSpriteEditor extends Blockly.Field implements Blockly.FieldCustom {
        isFieldCustom_: boolean;
        private params;
        private blocksInfo;
        private editor;
        private state;
        private lightMode;
        constructor(text: string, params: any, validator?: Function);
        init(): void;
        /**
         * Show the inline free-text editor on top of the text.
         * @private
         */
        showEditor_(): void;
        private isInFlyout();
        render_(): void;
        getText(): string;
        setText(newText: string): void;
        private redrawPreview();
        private parseBitmap(newText);
        /**
         * Scales the image to 32x32 and returns a data uri. In light mode the preview
         * is drawn with no transparency (alpha is filled with background color)
         */
        private renderPreview();
    }
}
